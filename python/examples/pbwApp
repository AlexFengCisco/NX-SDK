#!/isan/bin/nxpython

################################################################
#Copyright (c) 2016-2017
#All rights reserved.
################################################################

##################################################################
### pbwApp
###
### This example Python application shows the usage of the NXSDK.
### It creates custom show commands to show port bandwidth utilization 
### percentage. When the App gets started in the switch, following 
### commands gets created
###     CMD   :  show <appname> port bw utilization [<port>]
###     Action:  Displays port bandwidth utilization percentage for 
###              all ports if <port> is not specficied (or) just for.
###              a given port.
###
### Sample output:
###
### switch(config)# sh pbwApp port bw utilization 
### Interface       Bw (Rx/Tx sec Rate) Tx_BW percentage  RX_BW percentage          
### --------------- ------------------- ----------------  ----------------
### 
### Ethernet1/1     10 Gbps (30/30)               30.00           40.00
### Ethernet1/2     10 Gbps (30/30)               35.00            5.00
### 
##################################################################
import signal
import time
import threading
import sys
import os
import ctypes
import json
import re
import urllib2
from pprint import pprint
###import random
import cisco
from cli import *
import nx_sdk_py

### inherit from the NxCmdHandler class, define the application
### callback in 'postCliCb'.  The callback handler gets a pointer
### to this NxCmdHandler object and also the NxCliCmd object.

def print_port_bw (result):
    for key in result:
        key_ascii = str(key.encode('ascii','ignore'))
        value_ascii = str(result[key].encode('ascii','ignore'))
        if "interface" in key_ascii:
           interface = value_ascii
           if "mgmt" in interface:
              return ""
        if "eth_bw" in key_ascii:
           eth_bw = int(value_ascii)
        if "eth_load_interval1_tx" in key_ascii:
           tx_rate = int(value_ascii)
        if "eth_load_interval1_rx" in key_ascii:
           rx_rate = int(value_ascii)
        if "eth_outrate1_bits" in key_ascii:
           tx_bits = int(value_ascii)
           ###tx_bits = random.randint(eth_bw, eth_bw * 1000)
        if "eth_inrate1_bits" in key_ascii:
           rx_bits = int(value_ascii)

    bw_str = "%d Gbps (%d/%d)" % (eth_bw/1000000, rx_rate, tx_rate)
    tx_percentage = float((tx_bits * 100)/(eth_bw * 1000)) 
    rx_percentage = float((rx_bits * 100)/(eth_bw * 1000))
    print_str = '{0:15} {1:20} {2:18.2f} {3:18.2f}'.format(interface, bw_str, tx_percentage, rx_percentage)      
    return print_str


class pyCmdHandler(nx_sdk_py.NxCmdHandler):
        def postCliCb(self,clicmd):
                global p
                if "show_port_bw_util_cmd" in clicmd.getCmdName():
                   port = nx_sdk_py.void_to_string(clicmd.getParamValue("<port>"))
	           if port:
                        result = p.execShowCmd("show int %s" % str(port), nx_sdk_py.R_JSON)           
                   else:
                        result = p.execShowCmd("show int", nx_sdk_py.R_JSON)
                   print_str = '{0:15} {1:20} {2:18} {3:18}'.format("Interface", "Bw (Rx/Tx Sec Rate)", "Tx_BW percentage", "RX_BW percentage")
                   clicmd.printConsole("%s\n" % print_str)
                   clicmd.printConsole("--------------- -------------------- ------------------ ------------------\n") 
                   if not result:
                      return True
                   json_res = json.loads(result)["TABLE_interface"]["ROW_interface"]
                   for key in json_res:
                       if type(key) == dict:
                          clicmd.printConsole("%s\n" % print_port_bw(key))
                          continue
                       clicmd.printConsole("%s\n" % print_port_bw(json_res))
                       break
                return True 

### perform the event handling loop in a dedicated Python thread.
### All SDK related activities happen here, while the main thread
### may continue to do other work.  The call to startEventLoop will
### block until we break out of it by calling stopEventLoop on 

def evtThread(name,val):
    global p, sdk, event_hdlr

    sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
    if not sdk:
        return    

    sdk.setAppDesc('NXOS Port BW Percentage Utilzation Python App')

    t = sdk.getTracer()
    t.event("[%s] Started service" % sdk.getAppName())

    p = sdk.getCliParser()
    nxcmd1 = p.newShowCmd("show_port_bw_util_cmd", "port bw utilization [<port>]")
    nxcmd1.updateKeyword("port", "Port Information")
    nxcmd1.updateKeyword("bw", "Port Bandwidth Information")
    nxcmd1.updateKeyword("utilization", "Port BW utilization in (%)")
    nxcmd1.updateParam("<port>", "Optional Filter Port Ex) Ethernet1/1", nx_sdk_py.P_INTERFACE)
    
    ### define our application callback for this new command
    mycmd = pyCmdHandler()
    p.setCmdHandler(mycmd)

    ### install the new commands to the NXOS parse tree
    t.event("Adding commands to CLIS parse tree")
    p.addToParseTree()
    
    ### block in the event loop to service NXOS messages
    print("Starting event loop, CTRL-C to interrupt")
    sdk.startEventLoop()

    ### got here by calling stopEventLoop from signal handler
    t.event("Service Quitting...!")
    event_hdlr = False
  
    ### [Required] Needed for graceful exit.  
    nx_sdk_py.NxSdk.__swig_destroy__(sdk)

# main

p = 0
sdk = 0
event_hdlr = True

thread = threading.Thread(target=evtThread, args=("evtThread",0))
thread.start()
thread.join()
