#!/isan/bin/python

################################################################
Copyright (c) 2016-2017
All rights reserved.
################################################################

### TestApp.py
###
### This example Python application shows the usage of the NXSDK.
### Most of the public APIs are exercised, and this can be used
### as a reference when developing other applications.  Note that
### the 'nx_sdk_py' module is imported, so a prerequisite is that
### the nx_sdk_py.py module and the _nx_sdk_py.so extension lib
### are present and accessible to the application.  The usage here
### does not imply the only way the SDK may be used, and there
### may be functionality not exercised in this example.  Refer to
### the NXSDK documentation for details.
###
##################################################################

import signal
import time
import thread
import sys
import nx_sdk_py


### inherit from the NxCmdHandler class, define the application
### callback in 'postCliCb'.  The callback handler gets a pointer
### to this NxCmdHandler object and also the NxCliCmd object.

class pyCmdHandler(nx_sdk_py.NxCmdHandler):
        def postCliCb(self,clicmd):
                print ("===== pyCmdHandler called! =====")
                print("param1 (self): %s" % self)
                print("param2 (clicmd): %s" % clicmd)
                print("cmdname : %s" % clicmd.getCmdName())
                print("cmdline: %s" % clicmd.getCmdLineStr())
                print("cmderr : %s" % clicmd.getCmdErr())
                clicmd.printConsole("App handler for %s called" % \
                                            clicmd.getCmdName())
                

### install a handler to catch CTRL-C from the user.  The first
### call stops the event thread from servicing NXOS messages such
### as any new commands that were installed.  The second CTRL-C
### event exits the application.

def sig_handler(signal, frame):
    global p, sdk, event_hdlr

    print("Caught CTRL-C...")

    if (event_hdlr):
        sdk.stopEventLoop()
        print("Next CTRL-C stops application")
    else: 
        quit()

### perform the event handling loop in a dedicated Python thread.
### All SDK related activities happen here, while the main thread
### may continue to do other work.  The call to startEventLoop will
### block until we break out of it by calling stopEventLoop on 
### CTRL-C signal.

def evtThread(name,val):
    global p, sdk, event_hdlr

    sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)

    sdk.setAppDesc('NXOS Test Python App')

    print("------------")
    print("AppDesc: %s" % sdk.getAppDesc())
    print("AppName: %s" % sdk.getAppName())
    print("AppId  : %d" % sdk.getAppId())
    print("------------")
    
    p = sdk.getCliParser()
    
    t = sdk.getTracer()
    
    print("Printing some enum constants")
    print("EMERG: %d" % t.EMERG)
    print("ALERT: %d" % t.ALERT)
    print("CONF_MODE: %d" % nx_sdk_py.NxCliCmd.CONF_MODE)
    print("EXEC_MODE: %d" % nx_sdk_py.NxCliCmd.EXEC_MODE)
    print("MAX_MODE: %d" % nx_sdk_py.NxCliCmd.MAX_MODE)
    print("CONF_CMD: %d" % nx_sdk_py.NxCliCmd.CONF_CMD)
    print("SHOW_CMD: %d" % nx_sdk_py.NxCliCmd.SHOW_CMD)
    print("MAX_CMD: %d" % nx_sdk_py.NxCliCmd.MAX_CMD)
    print("----------")
    
    print("Sending messages to Tracer")
    t.syslog(t.ALERT, "[%s] Trace syslog ALERT msg..." % sdk.getAppName() )
    t.event("[%s] Trace event msg..." % sdk.getAppName())
    t.error("[%s] Trace error msg..." % sdk.getAppName())
    
    nxcmd1 = p.newCliCmd(nx_sdk_py.NxCliCmd.CONF_CMD, "py_cmd1", "py_cmd1 <arg1>")
    nxcmd1.addTimeout(4)
    nxcmd1.updateKeyword("py_cmd1", "this is the py_cmd1 keyword")
    print("cmd1 --------")
    print(nxcmd1)
    print("getCmdName : %s " % nxcmd1.getCmdName())
    print("getCmdType : %s " % nxcmd1.getCmdType())
    print("getCmdMode : %s " % nxcmd1.getCmdMode())
    print("getCmdSyntax : %s " % nxcmd1.getCmdSyntax())
    
    
    nxcmd2 = p.newShowCmd("py_cmd2", "py_cmd2 <arg1>")
    nxcmd2.addTimeout(3)
    nxcmd2.updateKeyword("py_cmd2", "this is the py_cmd2 keyword")
    nxcmd2.updateParam("<arg1>", "Arg1 string test...",64,None,False,0)
    print("cmd2 --------")
    print(nxcmd2)
    print("getCmdName : %s " % nxcmd2.getCmdName())
    print("getCmdType : %s " % nxcmd2.getCmdType())
    print("getCmdMode : %s " % nxcmd2.getCmdMode())
    print("getCmdSyntax : %s " % nxcmd2.getCmdSyntax())
    
    nxcmd3 = p.newConfigCmd("py_cmd3", "py_cmd3 <arg1>")
    nxcmd3.addTimeout(3)
    nxcmd3.updateKeyword("py_cmd3", "this is the py_cmd3 keyword")
    print("cmd3 --------")
    print(nxcmd3)
    print("getCmdName : %s " % nxcmd3.getCmdName())
    print("getCmdType : %s " % nxcmd3.getCmdType())
    print("getCmdMode : %s " % nxcmd3.getCmdMode())
    print("getCmdSyntax : %s " % nxcmd3.getCmdSyntax())

    ### define our application callback for this new command
    mycmd = pyCmdHandler()
    print("----mycmd----")
    print(mycmd)
    p.setCmdHandler(mycmd)

    ### install the new commands to the NXOS parse tree
    print("Adding commands to parse tree, check it....")
    p.addToParseTree()
    
    ### block in the event loop to service NXOS messages
    print("Starting event loop, CTRL-C to interrupt")
    sdk.startEventLoop()

    ### got here by calling stopEventLoop from signal handler
    print("evtThread stopping, got signal")
    p.delFromParseTree()
    print("Removed commands from parse tree")
    event_hdlr = False

# main

p = 0
sdk = 0

signal.signal(signal.SIGINT, sig_handler)

print("----------");
print("argc: %d" % len(sys.argv))
print("argv: %s" % sys.argv)
print("----------")

event_hdlr = True

### create new thread to setup SDK service and handle messages
thread.start_new_thread(evtThread, ("evtThread",0,))

### continue to do any useful work
while 1:
        time.sleep(2)
        print("main:  *")


