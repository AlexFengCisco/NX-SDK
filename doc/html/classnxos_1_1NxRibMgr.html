<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>NX-SDK: nxos::NxRibMgr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>nxos</b>::<a class="el" href="classnxos_1_1NxRibMgr.html">NxRibMgr</a>
  </div>
</div>
<div class="contents">
<h1>nxos::NxRibMgr Class Reference</h1><!-- doxytag: class="nxos::NxRibMgr" -->
<p>Abstract Rib Manager interface to gain access to NXOS RIB.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nx__rib__mgr_8h_source.html">nx_rib_mgr.h</a>&gt;</code></p>

<p><a href="classnxos_1_1NxRibMgr-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#a5f390bcc244b9f5984d35290aea0e2cc">~NxRibMgr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1NxVrf.html">NxVrf</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#a605323f1d764bc8c27fe770a9a6b4628">getVrf</a> (std::string vrfName=&quot;default&quot;, bool watch=false)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#a35e2a52be337d47cd111803f64aca904">watchVrf</a> (std::string vrfName=&quot;all&quot;)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#a957da78022cd4af95ee27941d0b67ce0">unwatchVrf</a> (std::string vrfName=&quot;all&quot;)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a> (<a class="el" href="classnxos_1_1NxRibMgrHandler.html">NxRibMgrHandler</a> *handler)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1NxRibMgrHandler.html">NxRibMgrHandler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#aeed917ba912782303662c4009f3fcfcd">getRibMgrHandler</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classnxos_1_1NxL3Route.html">NxL3Route</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#ae84cf1b9546fc3bf70e12bc7209ca190">getL3Route</a> (std::string routeAddr, unsigned char maskLen=0, std::string vrfName=&quot;default&quot;, bool clearBuffer=false)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#ab6749ea02f53fc8b2f6cdba21bbc335d">watchL3Route</a> (std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=nxos::MAX_AF)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnxos_1_1NxRibMgr.html#a1dc61ed1d830f50ea947707576d75b99">unwatchL3Route</a> (std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=nxos::MAX_AF)=0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract Rib Manager interface to gain access to NXOS RIB. </p>
<dl class="since"><dt><b>Since:</b></dt><dd>NX-SDK v1.5.0 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5f390bcc244b9f5984d35290aea0e2cc"></a><!-- doxytag: member="nxos::NxRibMgr::~NxRibMgr" ref="a5f390bcc244b9f5984d35290aea0e2cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual nxos::NxRibMgr::~NxRibMgr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor</p>
<p>To Delete the RIB manager instance and its associated objects gracefully. Its cleaned on delete sdk too. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae84cf1b9546fc3bf70e12bc7209ca190"></a><!-- doxytag: member="nxos::NxRibMgr::getL3Route" ref="ae84cf1b9546fc3bf70e12bc7209ca190" args="(std::string routeAddr, unsigned char maskLen=0, std::string vrfName=&quot;default&quot;, bool clearBuffer=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1NxL3Route.html">NxL3Route</a>* nxos::NxRibMgr::getL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>routeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>maskLen</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;default&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>clearBuffer</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To get the L3 Route based on the passed input parameters. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>routeAddr</em>&nbsp;</td><td>Address of the route as a string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maskeLen</em>&nbsp;</td><td>[Optional] MaskLength if its a prefix. If not set it will pick /32 for IP address (or) /128 for IPv6 address. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vrfName</em>&nbsp;</td><td>[Optional] VrfName in which the route is present. If not set "default" will be used. vrfName cannot be "all" or empty string "". </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>clearBuffer</em>&nbsp;</td><td>[Optional] If the route is present, <a class="el" href="classnxos_1_1NxRibMgr.html#ae84cf1b9546fc3bf70e12bc7209ca190">getL3Route()</a> creates a new <a class="el" href="classnxos_1_1NxL3Route.html" title="Abstract Route Interface to Add/Delete and receive Route updates from NXOS RIB.">NxL3Route</a> object. [Recommended] App owners must free/destory the L3 Route object once done. If they fail to free it, NX-SDK will store the object until its freed. NOTE: NX-SDK allows a max of 10 getL3Route Objects per VRF without having the Apps to free it explicitly. If user failed to cleanup after 10 getL3Route objects, it will raise an exception. If the App owners, failed/forgot to free the route object then set clearBuffer flag to True which will free all the previously created route objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classnxos_1_1NxL3Route.html" title="Abstract Route Interface to Add/Delete and receive Route updates from NXOS RIB.">NxL3Route</a> object if it exists. NULL if not (VrfName empty (or) "all", Vrf does not exist, down or invalid, no route etc).</dd></dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">       #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">       #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

       NxL3Route    *route;

       sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
       ribMgr = sdk-&gt;getRibMgr();

       route = ribMgr-&gt;getL3Route(<span class="stringliteral">&quot;10.1.1.1&quot;</span>, 24, <span class="stringliteral">&quot;default&quot;</span>);

  Python:
       <span class="keyword">import</span> nx_sdk_py
       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
       ribMgr = sdk.getRibMgr()

       route = ribMgr.getL3Route(<span class="stringliteral">&quot;10.1.1.1&quot;</span>, 24, <span class="stringliteral">&quot;default&quot;</span>)
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>invalid</em>&nbsp;</td><td>routeAddr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>invalid</em>&nbsp;</td><td>maskLen </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>getRoute</em>&nbsp;</td><td>buffer is full, cleanup previous pointers (or) call getL3Route with clearBuffer set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeed917ba912782303662c4009f3fcfcd"></a><!-- doxytag: member="nxos::NxRibMgr::getRibMgrHandler" ref="aeed917ba912782303662c4009f3fcfcd" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1NxRibMgrHandler.html">NxRibMgrHandler</a>* nxos::NxRibMgr::getRibMgrHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To get the Handler object registered with RIB Mgr. </p>

</div>
</div>
<a class="anchor" id="a605323f1d764bc8c27fe770a9a6b4628"></a><!-- doxytag: member="nxos::NxRibMgr::getVrf" ref="a605323f1d764bc8c27fe770a9a6b4628" args="(std::string vrfName=&quot;default&quot;, bool watch=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classnxos_1_1NxVrf.html">NxVrf</a>* nxos::NxRibMgr::getVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;default&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>watch</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To get the VRF object from a given name. Returns NULL if "all" (or) empty string "" is passed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vrfName</em>&nbsp;</td><td>name of the VRF in string. vrfName cannot be "all" or empty string "" </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>watch</em>&nbsp;</td><td>[Optional] set to True if this VRF needs to be tracked. By default, its set to False. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classnxos_1_1NxVrf.html" title="Abstract VRF Interface used to get details about a VRF.">NxVrf</a> Object if it exists. NULL if it does not exist.</dd></dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">       #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">       #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

       NxVrf *vrf;
       sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
       ribMgr = sdk-&gt;getRibMgr();

       vrf = ribMgr-&gt;getVrf(<span class="stringliteral">&quot;default&quot;</span>);

  Python:
       <span class="keyword">import</span> nx_sdk_py
       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
       ribMgr = sdk.getRibMgr()

       vrf = ribMgr.getVrf(<span class="stringliteral">&quot;default&quot;</span>)
</pre></div> <dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac42dd29e34f9c508614733dbec518b99"></a><!-- doxytag: member="nxos::NxRibMgr::setRibMgrHandler" ref="ac42dd29e34f9c508614733dbec518b99" args="(NxRibMgrHandler *handler)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::setRibMgrHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classnxos_1_1NxRibMgrHandler.html">NxRibMgrHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>handler</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Users to overload RIB Manager Handler class to handle regsiterd events like VRF, Route updates etc and register the handler object with RIB manager to handle rib events. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em><a class="el" href="classnxos_1_1NxRibMgrHandler.html" title="Abstract RibMgr callback Interface to receive VRF, Route updates etc from NXOS RIB...">NxRibMgrHandler</a></em>&nbsp;</td><td>object with user overloaded functions to handle rib events.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

     <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {
        <span class="keyword">public</span>:
           <span class="keywordtype">bool</span> postL3RouteCb(NxL3Route *route) {
                <span class="comment">// Do your action</span>
           }
     };

     <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
     {
          NxSdk    *sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
          NxRibMgr *ribMgr = sdk-&gt;getRibMgr();
          NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrHandler();
          ribMgr-&gt;setRibMgrHandler(myribcb);
     }

  Python:
     <span class="keyword">import</span> nx_sdk_py

     <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):
<span class="preprocessor">     ### Overloaded Callback to get Route events</span>
<span class="preprocessor"></span>           def postL3RouteCb(self, nxroute):
<span class="preprocessor">               # Do your action here</span>
<span class="preprocessor"></span>
<span class="preprocessor">     # Do SDK related inits in one thread.</span>
<span class="preprocessor"></span>     def sdkThread(name,val):
         sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
         ribMgr = sdk.getRibMgr()
         myribcb = myRibMgrHandler()
         ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)
</pre></div> 
</div>
</div>
<a class="anchor" id="a1dc61ed1d830f50ea947707576d75b99"></a><!-- doxytag: member="nxos::NxRibMgr::unwatchL3Route" ref="a1dc61ed1d830f50ea947707576d75b99" args="(std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=nxos::MAX_AF)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::unwatchL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nxos::af_e&nbsp;</td>
          <td class="paramname"> <em>af</em> = <code>nxos::MAX_AF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To unsubscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol/owner</em>&nbsp;</td><td>of the routes in NX RIB. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag</em>&nbsp;</td><td>[Optional] instance id of the owner for ex) for BGP - tag is the asn for isis - instance id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vrfName</em>&nbsp;</td><td>[Optional] Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrfName cannot be empty string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>af</em>&nbsp;</td><td>[Optional] Register for route events only from the specified address-family (af). For ex) To get only IPv4 route events, use AF_IPV4 etc. IF not speficied, it means from all AFs.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

     <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
     {
          NxSdk    *sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
          NxRibMgr *ribMgr = sdk-&gt;getRibMgr();
          ribMgr-&gt;unwatchL3Route(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>);
     }

  Python:
     <span class="keyword">import</span> nx_sdk_py

<span class="preprocessor">     # Do SDK related inits in one thread.</span>
<span class="preprocessor"></span>     def sdkThread(name,val):
         sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
         ribMgr = sdk.getRibMgr()
         ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#a1dc61ed1d830f50ea947707576d75b99">unwatchL3Route</a>(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>)
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a class="anchor" id="a957da78022cd4af95ee27941d0b67ce0"></a><!-- doxytag: member="nxos::NxRibMgr::unwatchVrf" ref="a957da78022cd4af95ee27941d0b67ce0" args="(std::string vrfName=&quot;all&quot;)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void nxos::NxRibMgr::unwatchVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;all&quot;</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To unsubscribe for any updates to this VRF. To unsubscribe for all VRF updates, use vrfName as "all". </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>VrfName</em>&nbsp;</td><td>[Optional] name of the vrf in string. If not specified, "all" is used to unwatch all VRFs. VrfName cannot be empty string.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">       #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">       #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

       NxVrf *vrf;
       sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
       ribMgr = sdk-&gt;getRibMgr();

       ribMgr-&gt;unwatchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>);

  Python:
       <span class="keyword">import</span> nx_sdk_py
       sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
       ribMgr = sdk.getRibMgr()

       ribMgr.unwatchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>)
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a class="anchor" id="ab6749ea02f53fc8b2f6cdba21bbc335d"></a><!-- doxytag: member="nxos::NxRibMgr::watchL3Route" ref="ab6749ea02f53fc8b2f6cdba21bbc335d" args="(std::string protocol, std::string tag=&quot;&quot;, std::string vrfName=&quot;all&quot;, nxos::af_e af=nxos::MAX_AF)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nxos::NxRibMgr::watchL3Route </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>tag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;all&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nxos::af_e&nbsp;</td>
          <td class="paramname"> <em>af</em> = <code>nxos::MAX_AF</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To receive/subscribe for Route updates based on protocol owner of the route, vrf, Address Family etc. To get the route updates, user overloaded postL3RouteCb handler will be called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol/owner</em>&nbsp;</td><td>of the routes in NX RIB. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tag</em>&nbsp;</td><td>[Optional] instance id of the owner for ex) for BGP - tag is the asn for isis - instance id </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vrfName</em>&nbsp;</td><td>[Optional] Register for route events only from this Vrf. If not specified, it means for all Vrfs. vrfName cannot be empty string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>af</em>&nbsp;</td><td>[Optional] Register for route events only from the specified address-family (af). For ex) To get only IPv4 route events, use AF_IPV4 etc. IF not speficied, it means from all AFs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool True - if successful. False - if not successful(Empty VRfName).</dd></dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">     #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">     #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

     <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {
        <span class="keyword">public</span>:
           <span class="keywordtype">bool</span> postL3RouteCb(NxL3Route *route) {
                cout &lt;&lt; <span class="stringliteral">&quot;Received bgp-100 updates for IPV4 routes on vpn1&quot;</span>;
           }
     };

     <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
     {
          NxSdk    *sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
          NxRibMgr *ribMgr;
          NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrMgrHandler();

          ribMgr = sdk-&gt;getRibMgr();
          <span class="keywordflow">if</span> (ribMgr) {
              ribMgr-&gt;setRibMgrHandler(myribcb);
              ribMgr-&gt;watchL3Route(<span class="stringliteral">&quot;bgp&quot;</span>, <span class="stringliteral">&quot;100&quot;</span>, <span class="stringliteral">&quot;vpn1&quot;</span>, nxos::AF_IPV4);
          }
     }

  Python:
     <span class="keyword">import</span> nx_sdk_py

     <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):
<span class="preprocessor">     ### Overloaded Callback to get Route events</span>
<span class="preprocessor"></span>           def postL3RouteCb(self, nxroute):
               print &quot;Received bgp-100 updates for IPV4 routes on vpn1&quot;

<span class="preprocessor">     # Do SDK related inits in one thread.</span>
<span class="preprocessor"></span>     def sdkThread(name,val):
         sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
         myribcb = myRibMgrHandler()
         if sdk:
            ribMgr = sdk.getRibMgr()
            if ribMgr:
               ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)
               ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#ab6749ea02f53fc8b2f6cdba21bbc335d">watchL3Route</a>(&quot;bgp&quot;, &quot;100&quot;, &quot;vpn1&quot;, nxos::AF_IPV4)
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reached</em>&nbsp;</td><td>maximum watch filter count: 15 for this Address-Family(AF) in this VRF.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: Use the pregenerated "show &lt;appname&gt; nxsdk ribMgr" command to verify if the API has succeeded. </p>

</div>
</div>
<a class="anchor" id="a35e2a52be337d47cd111803f64aca904"></a><!-- doxytag: member="nxos::NxRibMgr::watchVrf" ref="a35e2a52be337d47cd111803f64aca904" args="(std::string vrfName=&quot;all&quot;)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool nxos::NxRibMgr::watchVrf </td>
          <td>(</td>
          <td class="paramtype">std::string&nbsp;</td>
          <td class="paramname"> <em>vrfName</em> = <code>&quot;all&quot;</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>To receive/subscribe for any updates to this VRF. On any update to this VRF, users overloaded postVrfCb handler will be called. To subscribe for all VRFs, use vrfName as "all". NOTE: Forward referencing is allowed for a non created VRF i.e API can be called even if the VRF is not yet created. vrfName cannot be empty. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>VrfName</em>&nbsp;</td><td>[Optional] name of the vrf in string. If not specified, "all" is used to watch on all VRFs. VrfName cannot be empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool True - if successful. False - if not successful(Empty VRfName).</dd></dl>
<div class="fragment"><pre class="fragment">  C++:
<span class="preprocessor">       #include &lt;<a class="code" href="nx__sdk_8h.html" title="Abstract SDK interface to Nexus(NXOS) tools.">nx_sdk.h</a>&gt;</span>
<span class="preprocessor">       #include &lt;<a class="code" href="nx__rib__mgr_8h.html" title="Abstract SDK interface to Nexus(NXOS) Layer 3 Unicast RIB.">nx_rib_mgr.h</a>&gt;</span>

       <span class="keyword">class </span>myRibMgrMgrHandler : <span class="keyword">public</span> NxRibMgrHandler {
          <span class="keyword">public</span>:
             <span class="keywordtype">bool</span> postVrfCb(NxVrf *vrf) {
                  cout &lt;&lt; <span class="stringliteral">&quot;Vpn1 VRF changed&quot;</span>;
             }
       };

       <span class="keywordtype">int</span>  main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
       { 
            NxSdk    *sdk;
            NxRibMgr *ribMgr;
            NxVrf    *vrf;

            NxRibMgrHandler *myribcb = <span class="keyword">new</span> myRibMgrHandler();
            sdk = <a class="code" href="classnxos_1_1NxSdk.html#a5050e2d26c40744b4fc7862068a83f39">nxos::NxSdk::getSdkInst</a>(argc, argv);
            ribMgr = sdk-&gt;getRibMgr();
            ribMgr-&gt;setRibMgrHandler(myribcb);

            ribMgr-&gt;watchVrf(<span class="stringliteral">&quot;vpn1&quot;</span>);
       }

  Python:
     <span class="keyword">import</span> nx_sdk_py

     <span class="keyword">class </span>myRibMgrHandler(nx_sdk_py.NxRibMgrHandler):
<span class="preprocessor">     ### Overloaded Callback to get Route events</span>
<span class="preprocessor"></span>           def postVrfCb(self, nxvrf):
               print &quot;vpn1 has changed&quot;

<span class="preprocessor">     # Do SDK related inits in one thread.</span>
<span class="preprocessor"></span>     def sdkThread(name,val):
         sdk = nx_sdk_py.NxSdk.getSdkInst(len(sys.argv), sys.argv)
         ribMgr = sdk.getRibMgr()
         myribcb = myRibMgrHandler()
         ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#ac42dd29e34f9c508614733dbec518b99">setRibMgrHandler</a>(myribcb)

         ribMgr.<a class="code" href="classnxos_1_1NxRibMgr.html#a35e2a52be337d47cd111803f64aca904">watchVrf</a>(&quot;vpn1&quot;)
 NOTE: Use the pregenerated &quot;show &lt;appname&gt; nxsdk ribMgr&quot; command
       to verify if the API has succeeded.
</pre></div><dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vrfName</em>&nbsp;</td><td>is more than 32 characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/nobackup/sathsrin/trial/nxsdk/include/<a class="el" href="nx__rib__mgr_8h_source.html">nx_rib_mgr.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 21 Feb 2018 for NX-SDK by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
